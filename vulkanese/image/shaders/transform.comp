#version 450

#define LOCAL_SIZE 16
// This will be (or has been) replaced by constant definitions
layout(std140, set = 0, binding = 0 ) buffer inputImage_buf
{
    vec4 inputImage[1228800];
};
layout(std140, set = 0, binding = 1 ) buffer outputImage_buf
{
    vec4 outputImage[1228800];
};
layout(std140, set = 1, binding = 0 ) uniform paramsBuffer_buf
{
   float width;
float height;
float scaleX;
float scaleY;
float rotationAngle;
float translationX;
float translationY;
};
// This will be (or has been) replaced by buffer definitions
    
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1 ) in;

void main() {
    
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy); // Get the global ID of the thread
    if(gid.x >=width || gid.y>=height){
        return;
    }
    int dst_index = gid.y + int(gid.x *height);

    // center the coordinates
    vec2 centeredCoords = vec2(gid) - vec2(width, height) * 0.5;
    vec2 scaledCoords = centeredCoords/vec2(scaleX, scaleY);

    float cosAngle = cos(-rotationAngle); // Inverse rotation
    float sinAngle = sin(-rotationAngle);
    mat2 inverseRotationMatrix = mat2(cosAngle, sinAngle, -sinAngle, cosAngle);
    vec2 rotatedCoords = inverseRotationMatrix * scaledCoords;

    vec2 imageCenterCoords = rotatedCoords + vec2(width, height) * 0.5;
    vec2 transformedCoords = imageCenterCoords + vec2(translationX, translationY); // Transform back to pixel coordinates

    // Calculate the index based on gid
    int src_index = int(transformedCoords.y + int(transformedCoords.x) *height);

    // if the source is unsamplable, indicate black and return
    if(transformedCoords.x >=width || transformedCoords.y >=height){
        outputImage[dst_index] = vec4(0,0,transformedCoords.x,transformedCoords.y );
        outputImage[dst_index] = vec4(0,0,0,0);
        return;
    }
    // Directly pass the input to the output
    outputImage[dst_index] = inputImage[src_index];

}
